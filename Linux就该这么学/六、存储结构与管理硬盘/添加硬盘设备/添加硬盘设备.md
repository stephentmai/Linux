# 添加硬盘设备
按照前文讲解的 udev 服务命名规则，第二个被识别的 SATA 设备应该会被保存为/dev/sdb，这就是磁盘设备文件了。但在开始使用该磁盘之前，还需要进行分区操作，例如从中取出一个 2GB 的分区以供后面的操作使用。

fdisk 命令用于新建、修改及删除磁盘的分区表信息，英文全称为 format diskette，语法格式为“fdisk 磁盘名称”。

在Linux 系统中，管理磁盘设备最常用的方法就当属 fdisk 命令了。它提供了集添加、删除、转换分区等功能于一身的“一站式分区服务”。与此前介绍的将参数直接书写于命令后的形式不同，这条命令采用交互式的一问一答的形式接收参数（见表 6-5），因此在管理磁盘设备时特别方便，可以根据需求动态调整。

**fdisk 命令中的参数以及作用**

| 参数  |          作用          |
| :---: | :--------------------: |
|   m   |   查看全部可用的参数   |
|   n   |      添加新的分区      |
|   d   |    删除某个分区信息    |
|   l   | 列出所有可用的分区类型 |
|   t   |   改变某个分区的类型   |
|   p   |     查看分区表信息     |
|   w   |       保存并退出       |
|   q   |     不保存直接退出     |

首先使用 fdisk 命令尝试管理/dev/sdb 磁盘设备。在看到提示信息后输入参数 p，查看磁盘设备内已有的分区信息，其中包括磁盘的容量大小、扇区个数等信息：
```shell
root@linuxprobe:~# fdisk /dev/sdb

Welcome to fdisk (util-linux 2.40.2).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table.
Created a new DOS (MBR) disklabel with disk identifier 0x186f3f5e.

Command (m for help): p
Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors
Disk model: VMware Virtual S
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x186f3f5e
```
输入参数 n 尝试添加新的分区。系统会要求用户是选择继续输入参数 p 来创建主分区， 还是输入参数 e 来创建扩展分区。这里输入参数 p 来创建一个主分区：
```shell
Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
```
在确认创建一个主分区后，系统要求用户先输入主分区的编号。从前文得知，主分区的编号范围是 1～4，因此这里输入默认的 1 就可以了。接下来系统会提示定义起始的扇区位置， 这不需要改动，敲击回车键保留默认设置即可，系统会自动计算出最靠前的空闲扇区的位置。最后，系统会要求定义分区的结束扇区位置，这其实就是定义整个分区的大小是多少。我们不用去计算扇区的个数，只需要输入+2G 即可创建出一个容量为 2GB 的磁盘分区。
```shell
Partition number (1-4, default 1): 1
First sector (2048-41943039, default 2048): 此处敲击回车即可
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-41943039, default 41943039): +2G
Created a new partition 1 of type 'Linux' and of size 2 GiB.
```
再次使用参数 p 查看磁盘设备中的分区信息。果然就能看到一个名称为/dev/sdb1、起始扇区位置为 2048、结束扇区位置为 4196351 的主分区了。这时千万不要直接关闭窗口， 而应该敲击参数 w 后按回车键，这样分区信息才是真正地写入成功啦。
```shell
Command (m for help): p
Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors
Disk model: VMware Virtual S
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x186f3f5e

Device     Boot Start     End Sectors Size Id Type
/dev/sdb1        2048 4196351 4194304   2G 83 Linux

Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.
```
分区信息中第 6 个字段的 Id 值是一个编码，用于标识该分区的作用，可帮助用户快速了解该分区的作用，一般没必要修改。使用 l 参数查看一下磁盘编码都有哪些，然后在 6.6 节进行 SWAP 操作时再修改吧：
```shell
Command (m for help): l

00 Empty            27 Hidden NTFS Win  82 Linux swap / So  c1 DRDOS/sec (FAT-
01 FAT12            39 Plan 9           83 Linux            c4 DRDOS/sec (FAT-
02 XENIX root       3c PartitionMagic   84 OS/2 hidden or   c6 DRDOS/sec (FAT-
03 XENIX usr        40 Venix 80286      85 Linux extended   c7 Syrinx         
04 FAT16 <32M       41 PPC PReP Boot    86 NTFS volume set  da Non-FS data    
05 Extended         42 SFS              87 NTFS volume set  db CP/M / CTOS / .
06 FAT16            4d QNX4.x           88 Linux plaintext  de Dell Utility   
07 HPFS/NTFS/exFAT  4e QNX4.x 2nd part  8e Linux LVM        df BootIt         
08 AIX              4f QNX4.x 3rd part  93 Amoeba           e1 DOS access     
09 AIX bootable     50 OnTrack DM       94 Amoeba BBT       e3 DOS R/O        
0a OS/2 Boot Manag  51 OnTrack DM6 Aux  9f BSD/OS           e4 SpeedStor      
0b W95 FAT32        52 CP/M             a0 IBM Thinkpad hi  ea Linux extended 
0c W95 FAT32 (LBA)  53 OnTrack DM6 Aux  a5 FreeBSD          eb BeOS fs        
0e W95 FAT16 (LBA)  54 OnTrackDM6       a6 OpenBSD          ee GPT            
0f W95 Ext'd (LBA)  55 EZ-Drive         a7 NeXTSTEP         ef EFI (FAT-12/16/
10 OPUS             56 Golden Bow       a8 Darwin UFS       f0 Linux/PA-RISC b
11 Hidden FAT12     5c Priam Edisk      a9 NetBSD           f1 SpeedStor      
12 Compaq diagnost  61 SpeedStor        ab Darwin boot      f4 SpeedStor      
14 Hidden FAT16 <3  63 GNU HURD or Sys  af HFS / HFS+       f2 DOS secondary  
16 Hidden FAT16     64 Novell Netware   b7 BSDI fs          f8 EBBR protective
17 Hidden HPFS/NTF  65 Novell Netware   b8 BSDI swap        fb VMware VMFS    
18 AST SmartSleep   70 DiskSecure Mult  bb Boot Wizard hid  fc VMware VMKCORE 
1b Hidden W95 FAT3  75 PC/IX            bc Acronis FAT32 L  fd Linux raid auto
1c Hidden W95 FAT3  80 Old Minix        be Solaris boot     fe LANstep        
1e Hidden W95 FAT1  81 Minix / old Lin  bf Solaris          ff BBT            
24 NEC DOS        

Aliases:
   linux          - 83
   swap           - 82
   extended       - 05
   uefi           - EF
   raid           - FD
   lvm            - 8E
   linuxex        - 85
```
在上述步骤执行完毕之后，Linux 系统会自动把这个磁盘主分区抽象成/dev/sdb1 设备文件。可以使用 file 命令查看该文件的属性，但我在讲课和工作中发现，有时系统并没有自动把分区信息同步给 Linux 内核，而且这种情况似乎还比较常见（但不能算作严重的 bug）。此时需要输入 partprobe 命令手动将分区信息同步到内核，而且一般推荐连续两次执行该命令，效果会更好。如果使用这个命令都无法解决问题，那么就重启计算机吧，这个“杀手锏”百试百灵，一定会有用的。
```shell
root@linuxprobe:~# file /dev/sdb1
/dev/sdb1: cannot open `/dev/sdb1' (No such file or directory)
root@linuxprobe:~# partprobe
root@linuxprobe:~# partprobe
root@linuxprobe:~# file /dev/sdb1
/dev/sdb1: block special (8/17)
```
如果硬件存储设备没有进行格式化，则 Linux 系统无法得知怎么在其上写入数据。因此， 在对存储设备进行分区后还需要进行格式化操作。在 Linux 系统中用于格式化操作的命令是mkfs。这条命令很有意思，因为在 Shell 终端中输入 mkfs 后再敲击两下用于补齐命令的 Tab 键，会有如下所示的效果：
```shell
root@linuxprobe:~# mkfs
mkfs         mkfs.exfat   mkfs.ext3    mkfs.fat     mkfs.msdos   mkfs.xfs
mkfs.cramfs  mkfs.ext2    mkfs.ext4    mkfs.minix   mkfs.vfat       
```
对了！这个 mkfs 命令通过不同的参数来调用相应的文件系统格式化工具，实现对不同文件系统的格式化操作，用起来也非常简单—mkfs.文件类型名称。例如要将分区格式化成 XFS，则命令应为 mkfs.xfs /dev/sdb1。
```shell
root@linuxprobe:~# mkfs.xfs /dev/sdb1
meta-data=/dev/sdb1              isize=512    agcount=4, agsize=131072 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=1
         =                       reflink=1    bigtime=1 inobtcount=1 nrext64=1
data     =                       bsize=4096   blocks=524288, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
log      =internal log           bsize=4096   blocks=16384, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
```
终于完成了存储设备的分区和格式化操作，接下来就是挂载并使用存储设备了。与之相关的步骤也非常简单：首先创建一个用于挂载设备的挂载点目录；然后使用 mount 命令将存储设备与挂载点进行关联；最后使用 df -h 命令查看挂载状态和磁盘使用量信息。
```shell
root@linuxprobe:~# mkdir /newFS
root@linuxprobe:~# mount /dev/sdb1 /newFS
root@linuxprobe:~# df -h
Filesystem             Size  Used Avail Use% Mounted on
/dev/mapper/rhel-root   17G  3.7G   13G  23% /
devtmpfs               4.0M     0  4.0M   0% /dev
tmpfs                  1.9G   84K  1.9G   1% /dev/shm
efivarfs               256K   56K  196K  23% /sys/firmware/efi/efivars
tmpfs                  776M  9.7M  767M   2% /run
tmpfs                  1.0M     0  1.0M   0% /run/credentials/systemd-journald.service
/dev/sda2              960M  272M  689M  29% /boot
/dev/sr0               6.5G  6.5G     0 100% /media/cdrom
/dev/sda1              599M  8.3M  591M   2% /boot/efi
tmpfs                  388M  120K  388M   1% /run/user/0
/dev/sdb1              2.0G   71M  1.9G   4% /newFS
```
既然存储设备已经顺利挂载，接下来就可以尝试通过挂载点目录向存储设备中写入文件了。在写入文件之前，先来看一个用于查看文件数据占用量的 du 命令。du 命令用来查看分区或目录所占用的磁盘容量大小，英文全称为 disk usage，语法格式为“du –sh 目录名称”。简单来说，该命令就是用来查看一个或多个文件占用了多大的磁盘空间。

在使用 Windows 系统时，我们总会遇到“C 盘容量不足，清理垃圾后又很快被占满”的情况。在 Linux 系统中可以使用 du –sh /*命令查看根目录下所有一级目录分别占用的空间大小，在 1s 之内就能找到哪个目录占用的空间最多：
```shell
root@linuxprobe:~# du -sh /*
0		/afs
0		/bin
229M	/boot
84K		/dev
29M		/etc
12K		/home
0		/lib
0		/lib64
6.5G	/media
0		/mnt
0		/newFS
0		/opt
0		/proc
4.2M	/root
9.8M	/run
0		/sbin
0		/srv
0		/sys
20K	/tmp
3.2G	/usr
69M		/var
```
先从某些目录中复制过来一批文件，然后查看这些文件总共占用了多大的容量：
```shell
root@linuxprobe:~# cp -rf /etc/* /newFS
root@linuxprobe:~# ls /newFS
adjtime                  gshadow                   profile
aliases                  gshadow-                  profile.d
alsa                     gss                       protocols
alternatives             host.conf                 pulse
anacrontab               hostname                  qemu-ga
asound.conf              hosts                     ras
………………省略部分输出信息………………
root@linuxprobe:~# du -sh /newFS
29M /newFS/
```
细心的读者一定还记得，前面在讲解 mount 命令时提到，使用 mount 命令挂载的设备文件会在系统下一次重启时失效。如果想让这个设备文件的挂载永久有效，则需要把挂载的信息写入配置文件中：
```shell
root@linuxprobe:~# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Wed Mar 12 19:35:26 2025
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
UUID=408f4a3d-a4d3-4a44-bb23-6988cdbd10bf /             xfs     defaults        0 0
UUID=4cf8ecae-bcb6-4b1e-8001-968b33643a8a /boot         xfs     defaults        0 0
UUID=1FB8-9199          /boot/efi               vfat    umask=0077,shortname=winnt 0 2
UUID=d936c726-45a7-4ca2-8932-c54f84a3d787 none          swap    defaults        0 0
/dev/cdrom 				/media/cdrom 					iso9660 defaults 		0 0
/dev/sdb1  				/newFS       					xfs     defaults 		0 0
```

