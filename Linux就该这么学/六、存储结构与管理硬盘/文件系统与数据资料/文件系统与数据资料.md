# 文件系统与数据资料
同学们可以拿出一张 A4 纸，然后横过来在上面随便写上几行字，在书写过程中慢慢就会发现字写得越来越歪，最终整行文字都会向上或向下倾斜。为了能让字写得更工整，让人阅读得更舒服一些，文具店里提供了各种不同的本本—单线本、双线本、田格本、五线谱本等。这也说明，离开了格式约束后的内容，完全不受我们的主观控制。而用户在硬件存储设备中执行的文件建立、写入、读取、修改、转存与控制等操作，都是依靠文件系统来完成的。文件系统的作用是有效管理和优化磁盘空间的使用，以保证用户正常的使用需求。

Linux 系统支持数十种文件系统，最常见的文件系统如下所示。

Ext2：最早可追溯到 1993 年，是 Linux 系统的第一个商业级文件系统，它基本沿袭了 UNIX 文件系统的设计标准。由于不包含日志功能，Ext2 在系统崩溃后很难恢复数据，数据丢失的可能性较大。因此，建议大家能不用就不用，或者顶多用于 SD 存储卡或 U 盘。

Ext3：是一款日志文件系统，它会预先记录每个写入动作的细节，然后再进行实际写入操作，以便在异常宕机后能回溯追踪到被中断的部分。Ext3 能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。然而，当磁盘容量较大时，修复时间会很长，而且也不能 100%地保证资料不会丢失。

Ext4：Ext3 的改进版本，作为 RHEL 6 系统中的默认文件系统，它支持的存储容量高达 1EB（1EB=1073741824GB），且支持大量的子目录。Ext4 文件系统能够批量分配块，从而极大地提高了读写效率。现在很多主流服务器使用的就是 Ext4 文件系统。

XFS：是一种高性能的日志文件系统，从 RHEL 7 开始成为 RHEL 的默认文件系统。它在发生意外宕机后能够快速恢复被破坏的文件，且强大的日志功能只需消耗很低的计算和存储性能。它支持的最大存储容量为 18EB，几乎满足了所有需求。

RHEL 10 系统的一个重大变化就是使用了 XFS 作为文件系统。虽然红帽公司官方发布的说明认为这是一个巨大的进步，但刘遄老师经实测后发现情况并非全然如此。测试一款文件系统的“读取”性能涉及许多变量，包括读取文件的数量和大小、CPU 和内存等系统资源的占用率以及不同硬件配置的影响，因此不能盲目采信官方介绍。尽管 XFS 在性能方面比 Ext4 有所提升，但绝不是压倒性的，XFS 文件系统最卓越的亮点应该是其支持高达 18EB 的存储容量。

18EB 等于 18874368TB。假设每块磁盘的容量是 100TB，那么大概需要 19 万块磁盘才能装下 18EB 的数据。总之，使用 XFS 后，文件的存储上限不再取决于技术，而是取决于钱包。曾经有个技术圈的经典玩笑：“如果有 18EB 的数据在上海机房，想以最快的方式传送到北京，最好的办法是什么？”答案是“乘坐京沪高铁”。

拿到一块新的磁盘存储设备后，首先需要分区，然后再格式化文件系统，最后才能挂载并正常使用。磁盘的分区操作取决于你的需求和磁盘大小；也可以选择不进行分区，但必须对磁盘进行格式化处理。

Tips ：
就像拿到了一张未裁切的全开纸那样，首先要进行裁切以方便使用（分区），接下来在裁切后的纸张上画格以便能工整书写（格式化），最后是正式使用（挂载）。

接下来向大家简单科普一下磁盘在格式化后发生的事情。再次强调，大家不用刻意去记住，只要能看懂就行了。

日常需要保存在磁盘中的数据实在太多了，因此Linux 系统中有一个名为super block 的“磁盘地图”。Linux 并不是把文件内容直接写入这个“磁盘地图”中，而是记录整个文件系统的信息。如果把所有文件内容都写入这里，它的体积将变得非常大，查询与写入速度也会变慢。Linux 只是把每个文件的权限与属性记录在 inode 中，每个文件占用一个独立的inode 表格，该表格的大小默认为 128 字节，记录的信息包括：

该文件的访问权限（read、write、execute）；

该文件的所有者与所属组（owner、group）；

该文件的大小（size）；

该文件的创建或内容修改时间（Ctime）；

该文件的最后一次访问时间（Atime）；

该文件的修改时间（Mtime）；

该文件的特殊权限（SUID、SGID、SBIT）；

该文件的真实数据地址（point）。

文件的实际内容则保存在 block 中（大小一般是 1KB、2KB 或 4KB），一个 inode 的默认大小仅为 128 字节，记录一个 block 则消耗 4 字节。当文件的 inode 被写满后，Linux 系统会自动分配出一个 block，专门用于像 inode 那样记录其他 block 块的信息，这样把各个 block 的内容串联在一起，就能让用户读到完整的文件内容了。对于存储文件内容的block，有下面两种常见的情况（以 4KB 大小的block 为例进行说明）。

情况 1：文件很小（1KB），但依然会占用一个 block，因此会潜在地浪费 3KB。

情况 2：文件很大（5KB），那么会占用两个 block（5KB−4KB 后剩下的 1KB 也要占用一个 block）。

大家看到这里，是不是觉得 Linux 系统好浪费啊？为什么最后一个 block 的容量总不能被完全使用呢？其实每个系统都是一样的，只不过大家此前没有留意过罢了。同学们可以随手查看一个电脑中已有的文件，看看文件的实际大小与占用空间是否一致，如图 6-6 所示。

![](img/图2025-12-07-20-50-29.png)
文件的实际大小与占用空间

inode 与 block 搭配使用才最终实现了用户读写文件内容的操作，但有点太抽象了， 为了更好地理解它们，请看图 6-7 所示的关系图。

![](img/图2025-12-07-20-50-47.png)
inode与block关系示意图

计算机系统在发展过程中产生了众多的文件系统，为了使用户在读取或写入文件时不用关心底层的磁盘结构，Linux 内核中的软件层为用户程序提供了一个虚拟文件系统（Virtual File System，VFS）接口，这样用户实际上在操作文件时就是统一对这个虚拟文件系统进行操作了。图 6-8 所示为 VFS 的架构示意图。从中可见，实际文件系统在 VFS 下隐藏了自己的特性和细节，这样用户在日常使用时会觉得“文件系统都是一样的”，也就可以随意使用各种命令在任何文件系统中进行各种操作了（比如使用 cp 命令复制文件）。

![](img/图2025-12-07-20-51-47.png)
VFS的架构示意图

VFS 也有点像一个翻译官。我们不需要知道对方的情况，只要告诉 VFS 想进行的操作是什么，它就会自动判断对方能够听得懂什么命令，然后翻译并交代下去。这样一来，用户不用操心这些“小事情”，只需专注于自己的操作即可。

Tips ：
在医学圈里有这样一句话：“当开始关注身体某个器官的时候，大概率是它最近不舒服了。”由于 VFS 太好用了，而且几乎不会出现任何问题，所以如果不在这里讲一下它的理论，相信很多同学很可能在多年后都不知道自己用过它。