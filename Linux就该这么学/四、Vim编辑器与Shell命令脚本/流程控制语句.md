# 流程控制语句
虽然我们已经学习了如何使用 Linux 命令、管道符、重定向以及条件测试语句来编写基本的Shell 脚本，但这些脚本在实际生产环境中并不适用。原因在于它们缺乏灵活性，无法根据实际工作需求调整执行命令，也无法基于某些条件实现自动循环执行。换句话说，它们无法根据变化的情况做出相应调整。

通常情况下，Shell 脚本会按照从上到下的顺序依次执行，尽管这种执行方式效率很高， 但如果其中一条命令失败，后续的命令都会受到影响。假如大家有一天遇到了心仪的他（她），心中默默地进行如下规划（见图 4-19）。

![](img/2025-12-04-14-28-43.png)
心中规划

## if 条件测试语句
if 条件测试语句使得脚本能够根据实际情况自动执行相应的命令。从技术角度来看，if 语句分为单分支结构、双分支结构和多分支结构，其复杂度随着灵活度逐级增加。

单分支的 if 语句由 if、then、fi 关键词组成，而且只在条件成立时才执行预设的命令，相当于口语中的“如果……那么……”。单分支的 if 语句属于最简单的一种条件判断结构，语法格式如图 4-20 所示。

![](img/2025-12-04-14-32-36.png)
      单分支的 if 条件语句


下面使用单分支的 if 条件语句来判断/media/cdrom 目录是否存在，若不存在就创建该目录，反之则结束条件判断和整个 Shell 脚本的执行。
```shell
root@linuxprobe:~# vim mkcdrom.sh
#!/bin/bash
DIR="/media/cdrom"
if [ ! -d $DIR ]
then    
        mkdir -p $DIR
fi 
```
由于第 5 章才讲解用户身份与权限，因此这里继续用“bash 脚本名称”的方式来执行脚本。在正常情况下，顺利执行完脚本文件后没有任何输出信息，但可以使用 ls 命令验证/media/cdrom 目录是否已经成功创建：
```shell
root@linuxprobe:~# bash mkcdrom.sh
root@linuxprobe:~# ls -ld /media/cdrom
drwxr-xr-x. 2 root root 6 Mar 13 00:00 /media/cdrom
```
双分支的 if 语句由 if、then、else、fi 关键词组成，它进行一次条件判断，若条件匹配则执行相应命令，否则执行另一命令，相当于口语中的“如果……那么……否则……”。双分支的 if 条件语句的语法格式如图 4-21 所示。
![](img/2025-12-04-14-35-50.png)
双分支的 if 条件语句

下面使用双分支的 if 条件语句来验证某台主机是否在线，然后根据返回值的结果，要么显示主机在线信息，要么显示主机不在线信息。这里的脚本主要使用 ping 命令来测试与对方主机的网络连通性，而 Linux 系统中的 ping 命令不像 Windows 中那样尝试 4 次就结束， 因此为了避免用户等待时间过长，需要通过-c 参数来规定尝试的次数，并使用-i 参数定义每个数据包的发送间隔，以及使用-W 参数定义等待超时时间。
```shell
root@linuxprobe:~# vim chkhost.sh
#!/bin/bash
ping -c 3 -i 0.2 -W 3 $1 &> /dev/null
if [ $? -eq 0 ]
then
        echo "Host $1 is On-line."
else
        echo "Host $1 is Off-line."
fi
```
我们在 4.2.3 节中用过$?变量，作用是显示上一次命令的执行返回值。若前面的那条语句成功执行，则$?变量会显示数字 0，反之则显示一个非零的数字（可能为 1，也可能为 2， 取决于系统版本）。因此，可以使用整数比较运算符来判断$?变量是否为 0，从而获知那条语句的最终判断情况。这里的服务器 IP 地址为 192.168.10.10，验证一下脚本的效果：
```shell
root@linuxprobe:~# bash chkhost.sh 192.168.10.10
Host 192.168.10.10 is On-line.
root@linuxprobe:~# bash chkhost.sh 192.168.10.20
Host 192.168.10.20 is Off-line.
```
多分支的 if 语句由 if、then、else、elif、fi 关键词组成，它进行多次条件判断， 任何一项匹配成功即执行相应命令，相当于口语中的“如果……那么……如果……那么……”。 if 条件语句的多分支结构是工作中最常使用的一种条件判断结构，尽管相对复杂但是更加灵活，语法格式如图 4-22 所示。

![](img/2025-12-04-16-50-15.png)
多分支的 if 条件语句

下面使用多分支的 if 条件语句来判断用户输入的分数在哪个成绩区间内，然后输出Excellent、Pass、Fail 等提示信息。在 Linux 系统中，read 是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，-p 参数用于向用户显示一些提示信息。

在下面的脚本示例中，只有当用户输入的分数大于等于 85 分且小于等于 100 分时，才输出Excellent 字样；若分数不满足该条件（即匹配不成功），则继续判断分数是否大于等于 70 分且小于等于 84 分，如果是，则输出 Pass 字样；若两次都落空（即两次的匹配操作都失败了），则输出 Fail 字样：
```
root@linuxprobe:~# vim chkscore.sh
#!/bin/bash
read -p "Enter your score（0-100）：" GRADE
if [ $GRADE -ge 85 ] && [ $GRADE -le 100 ] ; then
        echo "$GRADE is Excellent"
elif [ $GRADE -ge 70 ] && [ $GRADE -le 84 ] ; then
        echo "$GRADE is Pass"
else
        echo "$GRADE is Fail" 
fi
root@linuxprobe:~# bash chkscore.sh
Enter your score（0-100）：88
88 is Excellent
root@linuxprobe:~# bash chkscore.sh 
Enter your score（0-100）：80
80 is Pass
```
执行该脚本。当用户输入的分数分别为 30 和 200 时，其结果如下：
```shell
root@linuxprobe:~# bash chkscore.sh  
Enter your score（0-100）：30
30 is Fail
root@linuxprobe:~# bash chkscore.sh
Enter your score（0-100）：200 
200 is Fail
```
为什么输入的分数为 200 时，依然显示 Fail 呢？原因很简单，没有成功匹配脚本中的两个条件判断语句，因此自动执行了最终的兜底策略。可见，这个脚本还不是很完美， 建议读者自行完善这个脚本，使得用户在输入大于 100 或小于 0 的分数时，给予 Error 报错字样的提示。
## for 条件循环语句
for 循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理。当需要处理的数据有一个范围时，使用 for 循环语句就再适合不过了。for 循环语句的语法格式如图 4-23 所示。
![](img/2025-12-04-16-55-25.png)
for 循环语句

下面使用 for 循环语句从列表文件中读取多个用户名，然后逐一为其创建用户账户并设置密码。首先创建用户名称的列表文件 users.txt，每个用户名称单独占一行。读者可以自行决定具体的用户名称和个数：
```shell
root@linuxprobe:~# vim users.txt
andy
barry
carl
duke
eric
george
winston
```
接下来编写Shell 脚本 addusers.sh。在脚本中使用 read 命令读取用户输入的密码值， 然后赋值给 PASSWD 变量，并通过-p 参数向用户显示一段提示信息，告诉用户正在输入的内容即将作为账户密码。执行该脚本后，会自动从列表文件 users.txt 中获取所有的用户名，然后逐一使用“id 用户名”命令查看用户信息，并使用$?判断这条命令是否执行成功，也就是判断该用户是否已经存在。
```shell
root@linuxprobe:~# vim addusers.sh
#!/bin/bash
read -p "Enter The Users Password : " PASSWD
for UNAME in `cat users.txt`
do
        id $UNAME &> /dev/null
        if [ $? -eq 0 ]
        then
                echo "$UNAME , Already exists"
        else
                useradd $UNAME
                echo "$PASSWD" | passwd --stdin $UNAME &> /dev/null
                echo "$UNAME , Create success"
        fi
done
```
Tips ：
/dev/null 是一个被称作 Linux 黑洞的文件，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。

执行批量创建用户的 Shell 脚本 addusers.sh，在输入账户密码后，脚本将自动检查并创建这些账户。由于已经将多余的信息通过输出重定向符转移到/dev/null 黑洞文件中，因此在正常情况下，屏幕窗口除了 Create success（创建成功）的提示外不会有其他内容。

在 Linux 系统中，/etc/passwd 是用来保存用户信息的文件。如果想确认这个脚本是否成功创建了用户账户，可以打开这个文件，查看是否有新创建的用户信息。