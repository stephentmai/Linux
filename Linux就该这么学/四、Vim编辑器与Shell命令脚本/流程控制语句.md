# 流程控制语句
虽然我们已经学习了如何使用 Linux 命令、管道符、重定向以及条件测试语句来编写基本的Shell 脚本，但这些脚本在实际生产环境中并不适用。原因在于它们缺乏灵活性，无法根据实际工作需求调整执行命令，也无法基于某些条件实现自动循环执行。换句话说，它们无法根据变化的情况做出相应调整。

通常情况下，Shell 脚本会按照从上到下的顺序依次执行，尽管这种执行方式效率很高， 但如果其中一条命令失败，后续的命令都会受到影响。假如大家有一天遇到了心仪的他（她），心中默默地进行如下规划（见图 4-19）。

![](img/2025-12-04-14-28-43.png)
心中规划

## if 条件测试语句
if 条件测试语句使得脚本能够根据实际情况自动执行相应的命令。从技术角度来看，if 语句分为单分支结构、双分支结构和多分支结构，其复杂度随着灵活度逐级增加。

单分支的 if 语句由 if、then、fi 关键词组成，而且只在条件成立时才执行预设的命令，相当于口语中的“如果……那么……”。单分支的 if 语句属于最简单的一种条件判断结构，语法格式如图 4-20 所示。

![](img/2025-12-04-14-32-36.png)
      单分支的 if 条件语句


下面使用单分支的 if 条件语句来判断/media/cdrom 目录是否存在，若不存在就创建该目录，反之则结束条件判断和整个 Shell 脚本的执行。
```shell
root@linuxprobe:~# vim mkcdrom.sh
#!/bin/bash
DIR="/media/cdrom"
if [ ! -d $DIR ]
then    
        mkdir -p $DIR
fi 
```
由于第 5 章才讲解用户身份与权限，因此这里继续用“bash 脚本名称”的方式来执行脚本。在正常情况下，顺利执行完脚本文件后没有任何输出信息，但可以使用 ls 命令验证/media/cdrom 目录是否已经成功创建：
```shell
root@linuxprobe:~# bash mkcdrom.sh
root@linuxprobe:~# ls -ld /media/cdrom
drwxr-xr-x. 2 root root 6 Mar 13 00:00 /media/cdrom
```
双分支的 if 语句由 if、then、else、fi 关键词组成，它进行一次条件判断，若条件匹配则执行相应命令，否则执行另一命令，相当于口语中的“如果……那么……否则……”。双分支的 if 条件语句的语法格式如图 4-21 所示。
![](img/2025-12-04-14-35-50.png)
双分支的 if 条件语句

下面使用双分支的 if 条件语句来验证某台主机是否在线，然后根据返回值的结果，要么显示主机在线信息，要么显示主机不在线信息。这里的脚本主要使用 ping 命令来测试与对方主机的网络连通性，而 Linux 系统中的 ping 命令不像 Windows 中那样尝试 4 次就结束， 因此为了避免用户等待时间过长，需要通过-c 参数来规定尝试的次数，并使用-i 参数定义每个数据包的发送间隔，以及使用-W 参数定义等待超时时间。
```shell
root@linuxprobe:~# vim chkhost.sh
#!/bin/bash
ping -c 3 -i 0.2 -W 3 $1 &> /dev/null
if [ $? -eq 0 ]
then
        echo "Host $1 is On-line."
else
        echo "Host $1 is Off-line."
fi
```
我们在 4.2.3 节中用过$?变量，作用是显示上一次命令的执行返回值。若前面的那条语句成功执行，则$?变量会显示数字 0，反之则显示一个非零的数字（可能为 1，也可能为 2， 取决于系统版本）。因此，可以使用整数比较运算符来判断$?变量是否为 0，从而获知那条语句的最终判断情况。这里的服务器 IP 地址为 192.168.10.10，验证一下脚本的效果：
```shell
root@linuxprobe:~# bash chkhost.sh 192.168.10.10
Host 192.168.10.10 is On-line.
root@linuxprobe:~# bash chkhost.sh 192.168.10.20
Host 192.168.10.20 is Off-line.
```
多分支的 if 语句由 if、then、else、elif、fi 关键词组成，它进行多次条件判断， 任何一项匹配成功即执行相应命令，相当于口语中的“如果……那么……如果……那么……”。 if 条件语句的多分支结构是工作中最常使用的一种条件判断结构，尽管相对复杂但是更加灵活，语法格式如图 4-22 所示。

![](img/2025-12-04-16-50-15.png)
多分支的 if 条件语句

下面使用多分支的 if 条件语句来判断用户输入的分数在哪个成绩区间内，然后输出Excellent、Pass、Fail 等提示信息。在 Linux 系统中，read 是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，-p 参数用于向用户显示一些提示信息。

在下面的脚本示例中，只有当用户输入的分数大于等于 85 分且小于等于 100 分时，才输出Excellent 字样；若分数不满足该条件（即匹配不成功），则继续判断分数是否大于等于 70 分且小于等于 84 分，如果是，则输出 Pass 字样；若两次都落空（即两次的匹配操作都失败了），则输出 Fail 字样：
```
root@linuxprobe:~# vim chkscore.sh
#!/bin/bash
read -p "Enter your score（0-100）：" GRADE
if [ $GRADE -ge 85 ] && [ $GRADE -le 100 ] ; then
        echo "$GRADE is Excellent"
elif [ $GRADE -ge 70 ] && [ $GRADE -le 84 ] ; then
        echo "$GRADE is Pass"
else
        echo "$GRADE is Fail" 
fi
root@linuxprobe:~# bash chkscore.sh
Enter your score（0-100）：88
88 is Excellent
root@linuxprobe:~# bash chkscore.sh 
Enter your score（0-100）：80
80 is Pass
```
执行该脚本。当用户输入的分数分别为 30 和 200 时，其结果如下：
```shell
root@linuxprobe:~# bash chkscore.sh  
Enter your score（0-100）：30
30 is Fail
root@linuxprobe:~# bash chkscore.sh
Enter your score（0-100）：200 
200 is Fail
```
为什么输入的分数为 200 时，依然显示 Fail 呢？原因很简单，没有成功匹配脚本中的两个条件判断语句，因此自动执行了最终的兜底策略。可见，这个脚本还不是很完美， 建议读者自行完善这个脚本，使得用户在输入大于 100 或小于 0 的分数时，给予 Error 报错字样的提示。
## for 条件循环语句
for 循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理。当需要处理的数据有一个范围时，使用 for 循环语句就再适合不过了。for 循环语句的语法格式如图 4-23 所示。
![](img/2025-12-04-16-55-25.png)
for 循环语句

下面使用 for 循环语句从列表文件中读取多个用户名，然后逐一为其创建用户账户并设置密码。首先创建用户名称的列表文件 users.txt，每个用户名称单独占一行。读者可以自行决定具体的用户名称和个数：
```shell
root@linuxprobe:~# vim users.txt
andy
barry
carl
duke
eric
george
winston
```
接下来编写Shell 脚本 addusers.sh。在脚本中使用 read 命令读取用户输入的密码值， 然后赋值给 PASSWD 变量，并通过-p 参数向用户显示一段提示信息，告诉用户正在输入的内容即将作为账户密码。执行该脚本后，会自动从列表文件 users.txt 中获取所有的用户名，然后逐一使用“id 用户名”命令查看用户信息，并使用$?判断这条命令是否执行成功，也就是判断该用户是否已经存在。
```shell
root@linuxprobe:~# vim addusers.sh
#!/bin/bash
read -p "Enter The Users Password : " PASSWD
for UNAME in `cat users.txt`
do
        id $UNAME &> /dev/null
        if [ $? -eq 0 ]
        then
                echo "$UNAME , Already exists"
        else
                useradd $UNAME
                echo "$PASSWD" | passwd --stdin $UNAME &> /dev/null
                echo "$UNAME , Create success"
        fi
done
```
Tips ：
/dev/null 是一个被称作 Linux 黑洞的文件，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。

执行批量创建用户的 Shell 脚本 addusers.sh，在输入账户密码后，脚本将自动检查并创建这些账户。由于已经将多余的信息通过输出重定向符转移到/dev/null 黑洞文件中，因此在正常情况下，屏幕窗口除了 Create success（创建成功）的提示外不会有其他内容。

在 Linux 系统中，/etc/passwd 是用来保存用户信息的文件。如果想确认这个脚本是否成功创建了用户账户，可以打开这个文件，查看是否有新创建的用户信息。
```shell
root@linuxprobe:~# bash addusers.sh
Enter The Users Password : linuxprobe
andy , Create success
barry , Create success
carl , Create success
duke , Create success
eric , Create success
george , Create success
winston , Create success
root@linuxprobe:~# tail -6 /etc/passwd
andy:x:1001:1001::/home/andy:/bin/bash
barry:x:1002:1002::/home/barry:/bin/bash
carl:x:1003:1003::/home/carl:/bin/bash
duke:x:1004:1004::/home/duke:/bin/bash
eric:x:1005:1005::/home/eric:/bin/bash
george:x:1006:1006::/home/george:/bin/bash
winston:x:1007:1007::/home/winston:/bin/bash
```
大家还记得在学习双分支 if 条件语句时，用到的那个测试主机是否在线的脚本吗？既然我们现在已经掌握了 for 循环语句，不妨做些更酷的事情，比如尝试让脚本从文本中自动读取主机列表，然后自动逐个测试这些主机是否在线。

首先创建一个主机列表文件ipaddrs.txt，每行一个IP 地址：
```shell
root@linuxprobe:~# vim ipaddrs.txt
192.168.10.10
192.168.10.11
192.168.10.12
```
然后将前面的双分支 if 条件语句与 for 循环语句相结合，让脚本从主机列表文件ipaddrs.txt 中自动读取 IP 地址（用来表示主机）并将其赋值给 HLIST 变量，从而通过判断ping 命令执行后的返回值来逐个测试主机是否在线。脚本中出现的“$（命令）”是一种完全类似于第 3 章的转义字符中反引号命令的 Shell 操作符，效果同样是执行括号或双引号括起来的字符串中的命令。大家在编写脚本时，多学习几种类似的新方法，可在工作中大显身手：
```shell
root@linuxprobe:~# vim CheckHosts.sh
#!/bin/bash
HLIST=$(cat ~/ipaddrs.txt)
for IP in $HLIST
do
        ping -c 3 -i 0.2 -W 3 $IP &> /dev/null
        if [ $? -eq 0 ]  
        then
                echo "Host $IP is On-line."
        else
                echo "Host $IP is Off-line."
        fi
done
root@linuxprobe:~# bash CheckHosts.sh
Host 192.168.10.10 is On-line.
Host 192.168.10.11 is Off-line.
Host 192.168.10.12 is Off-line.
```
细心的读者应该发现了，Shell 脚本中的代码缩进格式会根据不同的语句而改变。这是由Vim 编辑器自动完成的，用户无须进行额外操作。但是，如果你使用的是 RHEL 7 及以前的版本，则没有这个自动缩进功能，不过功能不受影响，只是会影响阅读体验而已。

## while 条件循环语句
while 条件循环语句是一种让脚本根据某些条件来重复执行命令的语句，它的循环结构往往在执行前并不确定最终执行的次数，完全不同于 for 循环语句中有目标、有范围的使用场景。while 循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，若条件为假就结束循环。while 语句的语法格式如图 4-24 所示。

![](img/图2025-12-04-23-05-55.png)
while 条件循环语句

接下来结合使用多分支的 if 条件测试语句与 while 条件循环语句，编写一个用来猜测数值大小的脚本 Guess.sh。该脚本使用$RANDOM 变量调取出一个随机的数值（范围为 0～ 32767），然后将这个随机数对 1000 进行取余操作，并使用 expr 命令取得其结果，再将这个数值与用户通过 read 命令输入的数值进行比较判断。这个判断语句分为 3 种情况，分别是判断用户输入的数值是等于、大于还是小于使用 expr 命令取得的数值。当前，现在这些内容不是重点，我们要关注的是 while 条件循环语句中的条件测试始终为 true，因此判断语句会无限执行下去，直到用户输入的数值等于expr 命令取得的数值后，才会运行 exit 0 命令终止脚本的执行。
```shell
root@linuxprobe:~# vim Guess.sh
#!/bin/bash
PRICE=$(expr $RANDOM % 1000)
TIMES=0
echo "商品实际价格为0-999之间，猜猜看是多少？"
while true
do
        read -p "请输入猜测的价格数目：" INT
        let TIMES++
        if [ $INT -eq $PRICE ] ; then
                echo "恭喜您答对了，实际价格是 $PRICE"
                echo "总共猜测了 $TIMES 次"
                exit
        elif [ $INT -gt $PRICE ] ; then
                echo "太高了！"
        else
                echo "太低了！"
        fi
done
```
在这个 Guess.sh 脚本中，我们添加了一些交互式的信息，从而使得用户与系统的互动性得以增强。而且每当循环到 let TIMES++命令时都会让 TIMES 变量内的数值加 1，用来统计循环总计执行了多少次。这可以让用户得知在总共猜测了多少次之后，才猜对价格。
```shell
root@linuxprobe:~# bash Guess.sh
商品实际价格为0-999之间，猜猜看是多少？
请输入猜测的价格数目：500
太低了！
请输入猜测的价格数目：800
太高了！
请输入猜测的价格数目：650
太低了！
请输入猜测的价格数目：720
太高了！
请输入猜测的价格数目：690
太低了！
请输入猜测的价格数目：700
太高了！
请输入猜测的价格数目：695
太高了！
请输入猜测的价格数目：692
太高了！
请输入猜测的价格数目：691
恭喜您答对了，实际价格是 691
总共猜测了 9 次
```
当条件为 true（真）的时候，while 语句会一直循环下去，只有碰到exit 才会结束， 所以一定要记得加上 exit 哦。
## case 条件测试语句
如果你之前学习过 C 语言，看到这一小节的标题肯定会会心一笑：这不就是 switch 语句嘛！是的，case 条件测试语句和 switch 语句的功能非常相似！case 语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；如果数据不在所列 出的范围内，则会执行星号（*）中定义的默认命令。case 语句的语法结构如图 4-25 所示。